                          +-------------+
                          | MicroKernel |
                          |     (1)     |
                          +-------------+
                                 |
                                / \
       -------------------------   ------------------------------
      /            /                    \           \            \
   +-----+     +-------+              +-----+    +-------+    +-------+
   | M M |     | Clock |              | TTY |    | Disks |    | Other |
   | (2) |<###>|  (3)  |<############>| (4) |<##>|  (5)  |<##>|  (6)  |
   +-----+     +-------+              +-----+    +-------+    +-------+
      ^            |                     |           |            |
      |            |                     |           |            |
      +------------+----- calls to message primitives ------------+
         ^             ^             ^             ^             ^
         #             #             #             #             #
         #             #             #             #             #
         v             v             v             v             v
    +---------+   +---------+   +---------+   +---------+   +---------+
    |  User   |   |  User   |   |  User   |   |  User   |   |  User   |
    | Process |   | Process |   | Process |   | Process |   | Process |
    +---------+   +---------+   +---------+   +---------+   +---------+


<=> - Передача сообщений
<-  - Системный вызов или вызов процедуры

1. Микроядро выполняет только планирование процессов, при этом оно содержит
процедурные интерфейсы предназначенные для этого, типа sched(), start(),
stop() и т.д. Помимо основных структур ядра, в него входит таблица запростов
(Requests Table). Она представляет собой подобие таблицы прерываний. В неё
входят адреса процедур, которые необходимо вызвать при возникшем запросе.
Процедуры встраиваются в таблицу драйверами, которые представляют из себя
отдельно работающие задачи. Таким образом можно расширять ядро в стиле
ядра монолитной структуры.
 Некоторые замечания и дополнения: Ядро линкуется с библиотекой ядра KLIB, в
 которую входят функции необходимые драйверам, а также с библиотекой DLIB,
 которая используется драйверами. DLIB призвана уменьшить колличество
 повторяющегося кода в драйверах.
 Следует отметить, что драйвера имеют меньшие привелегии чем ядро, поэтому
 некоторые вызовы к ядру делаются через гейты.
 Теперь опять вернёмся к планированию. Драйвера являются особыми процессами,
 которые работают близко к ядру, тесно с ним взаимодействуя. При возникновении
 какого либо запроса драйверу, он выполняет его до конца. Драйвер не может быть
 прерван при планировании. Тем не менее драйвера способны использовать
 кооперативную многозадачность. Т.е. если в данный момент драйвер ожидает
 событие, либо есть возможность прекратить работу, то драйвер может
 самостоятельно передать управление ожидающему процессу или драйверу. Другими
 словами, драйвера имеют доступ к примитивам планирования и способны планировать
 процессы и другие драйвера в системе.
 
2. Менеджер памяти. Он предоставляет примитивы для доставки сообщений, которые
встраиваются в ядро как системные вызовы. Помимо сообщений, менеджер памяти
управляет памятью, выделяя и освобождая её регионы, а также строя виртуальные
адресные пространства. Ядро самостоятельно не способно управлять памятью!
Стоит отметить, что сам менеджер, а также все остальные драйверы системы
общаются друг с другом и пользовательскими процессами, используя сообщения,
механизм для передачи которых и предоставляет менеджер памяти.

3. Часы. Этот драйвер управляет часами, тревогами и т.д. А также осуществляет
планирование процессов во времени, выделяя одинаковые промежутки времени для
каждого, в зависимости от приоритета. Он вызывает функции микроядра,
предназначенные для планирования.

4. Терминал

5. Дисковая подсистема. Управляет устройствами хранения информации.

6. Драйверы остальных устройств.
